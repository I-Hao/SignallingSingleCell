---
title: "SignallingSingleCell"
geometry: margin=2cm
author: "Kyle Gellatly"
date: "`r Sys.Date()`"
output:
  html_document:
    highlight: tango
    theme: cerulean
    toc: yes
    toc_float : yes
# pdf_document:
#   highlight: tango
#   toc: yes
# output: rmarkdown::html_vignette
# vignette: >
#   %\VignetteIndexEntry{Vignette Title}
#   %\VignetteEngine{knitr::rmarkdown}
#   %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE, warning=FALSE, error=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "")
```


```{r, include=FALSE, cache=FALSE, warning=FALSE, error=FALSE}
library("SignallingSingleCell")
load("~/Documents/Work/Garber/Data/inDrop/mDC_UMIClean/1-RawFiles/mDC_0hr_1hr_4hr_CLEAN.Rdata")
sc_dat <- mDC_0hr_1hr_4hr_CLEAN
```

# Preprocessing

## Filtering

The first step is to filter your data to remove low quality cells. Often creating a histogram of the values and assigning cutoffs is simple and effective. Typically we remove all cells lower than 1000 UMIs / cell.

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
UMI_sum <- apply(sc_dat,2,sum)
range(UMI_sum)
qplot(UMI_sum, geom = "histogram")  

filtered_data <- pre_filter(input = sc_dat, threshold = 1, minCells = 10, minUMI = 1000, maxUMI = 7500)  

UMI_sum <- apply(filtered_data,2,sum)
range(UMI_sum)
qplot(UMI_sum, geom = "histogram")
dim(filtered_data)
```

## Constructing the ExpressionSet Class  

The ExpressionSet class (ex_sc) is an extremely convienient data structure that contains 3 dataframes. Now that we have a filtered dataset it can be stored in this format.  

exprs(ex_sc) is the expression data  
pData(ex_sc) is cell information, where rows are cells and columns are metadata  
fData(ex_sc) is gene information, where rows are genes and columns are metadata  
ncol(exprs(ex_sc)) == nrow(pData(ex_sc))  
nrow(exprs(ex_sc)) == nrow(fData(ex_sc))  

Now that we have our first information (UMI counts per cell) we can write that into the pData.

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
ex_sc_example <- construct_ex_sc(filtered_data)  

pData(ex_sc_example) <- cbind(pData(ex_sc_example), UMI_sum)
head(pData(ex_sc_example))
```

## Initial Dimension reduction

Before normalization preliminary dimensionality reduction is necessary to form preliminary clusters. These clusters are used to normalize internal to a cluster before normalizing across clusters. First we can subset the genes, and then use these feature selected genes for dimension reduction.

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
gene_subset <- subset_genes(input = ex_sc_example, method = "PCA", threshold = 3, minCells = 30, nComp = 10, cutoff = 0.75)  

ex_sc_example <- dim_reduce(input = ex_sc_example, genelist = gene_subset, pre_reduce = "iPCA", nComp = 15, tSNE_perp = 30, print_progress=TRUE)  

head(pData(ex_sc_example))
```

From this we can map on our UMI counts before normalization to view if there is any bias. We can also look at a gene of interest. To accomplish these we will take advantage of the ex_sc set once again.

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
prelim_dims_tsne <- pData(ex_sc_example)[,c("x", "y", "UMI_sum")]  

ggplot(prelim_dims_tsne) + 
  geom_point(aes(x = x, y = y, col = log2(UMI_sum))) +
  scale_color_gradientn(colours=c("gray", 'blue', 'red', 'yellow')) +
  theme_classic() + 
  labs(title= "Initial Positions", x = "tSNE[1]", y = "tSNE[2]")  

gene <- "Actb"
prelim_dims_tsne$gene <- log2(filtered_data[gene,]+2)-1  

ggplot(prelim_dims_tsne) + 
  geom_point(aes(x = x, y = y, col = gene)) +
  scale_color_gradientn(colours=c("gray", 'blue', 'red', 'yellow')) +
  theme_classic() + 
  labs(title= gene, x = "tSNE[1]", y = "tSNE[2]")
```

## Initial Clustering

After viewing a large UMI bias we can now use spectral clustering for intial clustering before normalization. It looks as though there are about 6 clusters.  

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
ex_sc_example <- cluster_sc(input = ex_sc_example, dimension = "Comp", method = "spectral", num_clust = 6)  

### Make a plot clusters function!!!

ggplot(pData(ex_sc_example)) + 
  geom_point(aes(x = x, y = y, col = Cluster)) +
  theme_classic() + 
  labs(title= "Initial Clusters", x = "tSNE[1]", y = "tSNE[2]")
```

## Identify markers and reference genes

For normalization and cluster id a function is provided that will id both marker genes and reference genes.

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
ex_sc_example <- id_markers(input = ex_sc_example, num_markers = 50, num_reference = 1000)

### Make a plot markers function!!!
rownames(fData(ex_sc_example))[which(fData(ex_sc_example)$Markers == "Cluster1")]
```


## Normalization

Now that the data has preliminary clusters, we can normalize. CPM and TMM normalization will not utilize these clusters, however the much more powerful SCRAN normalization will first normalize internally in clusters, before normalizing across clusters. Once the data is normalized we can run the same steps as above before visualization.

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
```
