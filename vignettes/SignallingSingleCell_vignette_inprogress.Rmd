---
title: "SignallingSingleCell"
geometry: margin=2cm
author: "Kyle Gellatly"
date: "`r Sys.Date()`"
output:
  html_document:
    highlight: tango
    theme: cerulean
    toc: yes
    toc_float : yes
# pdf_document:
#   highlight: tango
#   toc: yes
# output: rmarkdown::html_vignette
# vignette: >
#   %\VignetteIndexEntry{Vignette Title}
#   %\VignetteEngine{knitr::rmarkdown}
#   %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE, warning=FALSE, error=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "")
```


```{r, include=FALSE, cache=FALSE, warning=FALSE, error=FALSE}
library("SignallingSingleCell")
# load("~/Documents/Work/Garber/Data/inDrop/mDC_UMIClean/1-RawFiles/mDC_0hr_1hr_4hr_CLEAN.Rdata")
# sc_dat <- mDC_0hr_1hr_4hr_CLEAN

load("/Users/KGellatly/Documents/Work/Garber/Data/inDrop/Vitiligo/1_29_18/Vitiligo_1_29_18_1000UMI_MASTER.Rdata")
sc_dat <- master_data
```

# Preprocessing

## Constructing the ExpressionSet Class  

The ExpressionSet class (ex_sc) is an extremely convienient data structure that contains 3 dataframes. These dataframes contain expression data, cell information, and gene information respectivelty. 

exprs(ex_sc) is the expression data  
pData(ex_sc) is cell information, where rows are cells and columns are metadata  
fData(ex_sc) is gene information, where rows are genes and columns are metadata  
ncol(exprs(ex_sc)) == nrow(pData(ex_sc))  
nrow(exprs(ex_sc)) == nrow(fData(ex_sc))  

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
ex_sc_example <- construct_ex_sc(sc_dat) 
ex_sc_example
```

## Filtering

The first step is to filter your data to remove low quality cells. Often creating a histogram of the values and assigning cutoffs is simple and effective. Typically we remove all cells lower than 1000 UMIs / cell.

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
ex_sc_example <- calc_libsize(ex_sc_example)
draw_density(input = ex_sc_example, val = "UMIs", statistic = "mean")  

ex_sc_example <- pre_filter(input = ex_sc_example, threshold = 1, minCells = 10, minUMI = 1010, maxUMI = 10000)  
ex_sc_example <- calc_libsize(ex_sc_example)
draw_density(input = ex_sc_example, val = "UMIs", statistic = "mean")
```


## Initial Dimension reduction

Before normalization preliminary dimensionality reduction is necessary to form preliminary clusters. These clusters are used to normalize internal to a cluster before normalizing across clusters. First we can subset the genes, and then use these feature selected genes for dimension reduction.

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
gene_subset <- subset_genes(input = ex_sc_example, method = "PCA", threshold = 3, minCells = 30, nComp = 10, cutoff = 0.75)  

ex_sc_example <- dim_reduce(input = ex_sc_example, genelist = gene_subset, pre_reduce = "iPCA", nComp = 15, tSNE_perp = 30, iterations = 500, print_progress=TRUE)  

head(pData(ex_sc_example))

```

## Initial Clustering

After viewing a large UMI bias we can now use spectral clustering for intial clustering before normalization. It looks as though there are about 6 clusters.  

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
ex_sc_example <- cluster_sc(input = ex_sc_example, dimension = "Comp", method = "spectral", num_clust = 6)  

ggplot(pData(ex_sc_example)) + 
  geom_point(aes(x = x, y = y, col = Cluster)) +
  theme_classic() + 
  labs(title= "Initial Clusters", x = "tSNE[1]", y = "tSNE[2]")
# ggplot2::ggsave("Vitiligo_Clusters.pdf", width = 6, height = 6, useDingbats = F)

ggplot(pData(ex_sc_example)) + 
  scale_color_gradientn(colours=c("gray", 'blue', 'red', 'yellow')) +
  geom_point(aes(x = x, y = y, col = log10(UMI_sum))) +
  theme_classic() + 
  labs(title= "Initial Clusters", x = "tSNE[1]", y = "tSNE[2]")
# ggplot2::ggsave("Vitiligo_tSNE_UMI.pdf", width = 6, height = 6, useDingbats = F)

draw_density(input = ex_sc_example, val = "UMIs", var1 = "Cluster", statistic = "mean")
#  ggplot2::ggsave("Vitiligo_density_UMI.pdf", width = 6, height = 6, useDingbats = F)

```

## Identify markers and reference genes

For normalization and cluster id a function is provided that will id both marker genes and reference genes.

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
ex_sc_example <- id_markers(input = ex_sc_example, num_markers = 50, num_reference = 1000)
rownames(fData(ex_sc_example))[which(fData(ex_sc_example)$Markers == "Cluster5")]

gene <- "JCHAIN"
gene_Dat <- pData(ex_sc_example)[,c("x", "y")]
gene_Dat$gene <- log2(exprs(ex_sc_example)[gene,]+2)-1
gene_Dat <- gene_Dat[with(gene_Dat, order(gene_Dat[,c("gene")])), ]

ggplot(gene_Dat) + 
  scale_color_gradientn(colours=c("gray", 'blue', 'red', 'yellow')) +
  geom_point(aes(x = x, y = y, col = gene)) +
  theme_classic() + 
  labs(title= gene, x = "tSNE[1]", y = "tSNE[2]", col = paste0("log2(", gene, ")"))
```


## Normalization

Now that the data has preliminary clusters, we can normalize. CPM and TMM normalization will not utilize these clusters, however the much more powerful SCRAN normalization will first normalize internally in clusters, before normalizing across clusters. Once the data is normalized we can run the same steps as above before visualization.

```{r, include=TRUE, cache=FALSE, warning=FALSE, error=FALSE}
```
